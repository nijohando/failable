(ns jp.nijohando.failable-test
  (:refer-clojure :exclude [])
  (:require #?(:clj  [clojure.test :as t :refer [run-tests is are deftest testing]]
               :cljs [cljs.test :as t :refer-macros [run-tests is are deftest testing]])
            [jp.nijohando.failable :as f :include-macros true])
  #?(:clj (:import [clojure.lang ExceptionInfo])))


(deftest fail
  (testing "Failure can be created"
    (let [x (f/fail)]
      (is (f/fail? x))
      (is (nil? (f/reason x)))))
  (testing "Failure can be created with reason"
    (let [x (f/fail :foo)]
      (is (f/fail? x))
      (is (= :foo (f/reason x)))))
  (testing "Failure can be associated with any extra information"
    (let [msg "this is test"
          cause (ex-info "test" {})
          x (-> (f/fail ::foo)
                (assoc :msg msg)
                (assoc :cause cause))]
      (is (f/fail? x))
      (is (= msg (:msg x)))
      (is (= cause (:cause x))))))

(deftest ensure
  (testing "Value is just returned if it's not failure"
    (is (= :ok (f/ensure :ok)))
    (is (= true (f/ensure true)))
    (is (= false (f/ensure false)))
    (is (nil? (f/ensure nil))))
  (testing "Exception is thrown if value is failure"
    (let [x (f/fail)]
      (is (thrown-with-msg? #?(:clj Exception :cljs js/Error) #"^Failed to ensure value" (f/ensure x))))))

(deftest do*
  (testing "Forms are evaluated and the last value is returned"
    (let [x (atom [])]
      (is (= (f/do*
               (swap! x conj :d1)
               (swap! x conj :d2)) [:d1 :d2]))))
  (testing "Exception is converted into a failure, then returned"
    (let [x (f/do* (throw (ex-info "test" {})))]
      (is (f/fail? x)))))

(deftest flet
  (testing "Return value"
    (testing "Value is returned"
      (is (= 1 (f/flet [_ nil] 1))))
    (testing "Failure is returned"
      (let [x (f/fail)]
        (is (= x (f/flet [_ nil] x)))))
    (testing "Binding form is returned"
      (is (= 1 (f/flet [a 1] a))))
    (testing "Body form is evaluated and returned"
      (is (= 2 (f/flet [a 1] (inc a)))))
    (testing "Failure on bindings is just returned"
      (let [x (f/fail "error1")
            y (f/flet [_ x] 1)]
        (is (f/fail? y))
        (is (= x y))))
    (testing "Exception on bindings is not captured"
      (is (thrown-with-msg?
           #?(:clj clojure.lang.ExceptionInfo :cljs js/Error) #"^:test$"
           (f/flet [_ (throw (ex-info "test" {}))]
                   nil))))
    (testing "Exception on body is not captured"
      (is (thrown-with-msg?
           #?(:clj clojure.lang.ExceptionInfo :cljs js/Error) #"^:test$"
           (f/flet [_ 1]
             (throw (ex-info "test" {}))))))

    ))
